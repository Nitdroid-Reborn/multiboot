#!/bin/sh
#
# multiboot	Maemo ULTimate BOOTloader
#
#		Copyright (C) 2010  Jay Cartman <jay.cartman@gmail.com>
#

# Search path
export PATH=/usr/sbin:/usr/bin:/sbin:/bin

# Timeout for the menu
MAIN_TIMEOUT=15

# Configuration directory
CONFIG_D=/etc/multiboot.d

# init searchlist
INIT_SEARCH="sbin/preinit sbin/init bin/init init linuxrc"

# vmlinuz searchlist
VMLINUZ_SEARCH="boot/multiboot/vmlinuz- boot/multiboot/zImage- boot/vmlinuz- boot/zImage-"

# modules.boot searchlist
MODULES_SEARCH="lib/modules/current/modules.boot etc/modules.boot system/etc/modules.boot"

# slide switch search list
SLIDE_SEARCH="slide sw_lid"

# Boot files
BOOT_ITEM="/boot/multiboot/.multiboot.item"
BOOT_FAST="/boot/multiboot/.multiboot.fast"
BOOT_LOGF="/boot/multiboot/.multiboot.log"

# MMC Cards
EXT_CARD="mmcblk0"
INT_CARD="mmcblk1"

# Predefined items
ARRAY__NAME__0__="Maemo (default)"
ARRAY__KERNEL__0__="2.6.28-omap1"

# Flags
FAST_BOOT=NO
BOOT_STATE=USER

# Colours
if [ -e /etc/INSIDE_QEMU ]
then
	BLACK=0x000000
	WHITE=0xFFFFFF
	GREY=0x808080
	BLUE=0x0000FF
	RED=0xFF0000
else
	BLACK=0x0000
	WHITE=0xFFFF
	GREY=0x8410
	BLUE=0x001F
	RED=0xF800
fi


################################################################################################
#
# UTILITY FUNCTIONS
#
################################################################################################

array()
{
	eval echo "\${ARRAY__${1}__${2}__}"
}


SAY()
{
	echo -e "$@" >&2
}


LOG()
{
	echo -e "$@" >&5
}


RUN()
{
	eval "$@" >&5 2>&5
}


ERROR()
{
	LOG "*** ERROR" "$@"

	error_screen "$1"
	get_key 20000
	safe_reboot
}


run()
{
	LOG "    RUN [" "$@" "]"
	RUN "$@"
}


safe_reboot()
{
	echo -n ${BOOT_STATE} > /var/lib/dsme/saved_state

	LOG "Rebooting..."

	run mount / -o ro,remount
	run sync
	run reboot -f
}


safe_poweroff()
{
	echo -n ${BOOT_STATE} > /var/lib/dsme/saved_state

	LOG "Poweroff..."

	run mount / -o ro,remount
	run sync
	run poweroff -f
}


get_boot_state()
{
	local state reason saved

	LOG "System Information:"
	LOG "    kernel      $(uname -r)"
	LOG "    build       $(uname -v)"
	LOG "    nolo        $(cat /proc/component_version | fgrep nolo | cut -c 13-)"
	LOG "    hw-rev      $(cat /proc/component_version | fgrep hw-build | cut -c 13-)"

	reason=$(cat /proc/bootreason)

	LOG "Boot reason: $reason"

	if [ -e /var/lib/dsme/saved_state ]
	then
		saved=$(cat /var/lib/dsme/saved_state)
	else
		saved=MALF
	fi

	case "${reason}" in
		pwr_key)	state=USER	;;
		update)		state=FLASH	;;
		usb)		state=ACT_DEAD	;;
		charger)	state=ACT_DEAD	;;
		rtc_alarm)	state=ACT_DEAD	;;
		sw_rst)		state=${saved}	;;
		por)		state=${saved}	;;
		32wd_to)	state=${saved}	;;
		swdg_to)	state=${saved}	;;

		*)		state=MALF	;;
	esac

	LOG "Boot state: $state"

	BOOT_STATE=${state}
}


sysset()
{
	if [ -w /sys/$1 ]
	then
		LOG "    SET $1 $2"
		echo $2 > /sys/$1
	else
		LOG "*** WARNING: No such writable sysfs entry: $1"
	fi
}


get_key()
{
	/bin/evkey -d -t "$1" /dev/event1
}


is_slide_open()
{
	local name
	local state

	for name in ${SLIDE_SEARCH}
	do
		if [ -d /sys/devices/platform/gpio-switch/$name ]
		then
			state=$(cat /sys/devices/platform/gpio-switch/$name/state)
			LOG "Slide state from GPIO[$name]: $state"

			if [ X${state} = Xopen ]
			then
				return 0
			else
				return 1
			fi
		fi
	done

	state=$( /bin/evkey -s 0 /dev/event2 )
	if [ X$state = X1 ]
	then
		return 1
	fi

	state=$( /bin/evkey -s 0 /dev/event3 )
	if [ X$state = X1 ]
	then
		return 1
	fi

	LOG "*** WARNING: Slide state unknown"

	return 0
}


is_fast_boot()
{
	test X${FAST_BOOT} = XYES -a -f ${BOOT_ITEM}
}


is_proc_mounted()
{
	test -f /proc/sys/kernel/version
}


is_sys_mounted()
{
	test -d /sys/devices/system/cpu
}


is_tmp_mounted()
{
	if is_proc_mounted
	then
		cat /proc/mounts | cut -d' ' -f 2 | grep -E -q '^/tmp$'
	else
		return 1
	fi
}


is_dev_mounted()
{
	if is_proc_mounted
	then
		cat /proc/mounts | cut -d' ' -f 2 | grep -E -q '^/dev$'
	else
		return 1
	fi
}


is_pts_mounted()
{
	if is_proc_mounted
	then
		cat /proc/mounts | cut -d' ' -f 2 | grep -E -q '^/dev/pts$'
	else
		return 1
	fi
}


is_mod_mounted()
{
	if is_proc_mounted
	then
		cat /proc/mounts | cut -d' ' -f 2 | grep -E -q '^/lib/modules/'
	else
		return 1
	fi
}


mknod_misc()
{
	local NAME="$1"
	local DEV="$2"

	local a b c
	local minor=""

	if is_proc_mounted
	then
		minor=$(cat /proc/misc | grep -F "$DEV" | cut -f 1 -d' ')
	else
		case "$DEV" in
			watchdog)	minor=130 ;;
			twl4030_wdt)	minor=142 ;;
			twl4030-adc)	minor=58  ;;
			*)		minor=""  ;;
		esac
	fi

	if [ -n "${minor}" ]
	then
		run mknod "$NAME" c 10 "${minor}"
	else
		LOG "*** WARNING: No minor found for $DEV. Ignoring."
	fi
}


wait_root_device()
{
	local dev=$1
	local wait=$2

	LOG "Waiting for root device ${dev} (${wait}s)"

	while [ $wait -gt 0 ]
	do
		if grep -F -q $dev /proc/partitions
		then
			if [ -b /dev/$dev ]
			then
				LOG "Root device $dev OK"
				return 0
			else
				ERROR "Device node /dev/$dev NOT found!"
				return 1
			fi
		fi

		wait=$(( $wait - 1 ))
		sleep 1
	done

	ERROR "Root filesystem $dev NOT available!"

	return 1
}


load_kernel_modules()
{
	local FILE=""

	local file module args

	for file in ${MODULES_SEARCH}
	do
		if [ -e $file ]
		then
			FILE=$file
			break
		fi
	done

	if [ -f "${FILE}" ]
	then
		LOG "Loading kernel modules from ${FILE}"

		cat ${FILE} | grep -E -v '^#' | while read module args
		do
			if [ -n "${module}" ]
			then
				LOG "Loading module ${module}"
				run modprobe -i ${module} ${args}
			fi
		done
	fi
}


load_modules()
{
	local module

	for module
	do
		LOG "Loading module $module"
		run modprobe -i $module
	done
}


load_pmconfig()
{
	local FILE=$1/etc/power.conf

	if [ -e $FILE ]
	then
		LOG "Loading kernel power configuration from $FILE"
		run powerconfig $FILE
	fi
}


read_config()
{
	local file
	local i=1

	ITEM_LIST=""

	for file in ${CONFIG_D}/*.item
	do
		if [ -e "$file" ]
		then
			LOG "Reading boot item [$i] from file $file"

			eval $( /sbin/multiboot_read_item FN=$i $file )

			ITEM_LIST="${ITEM_LIST} $i"
			i=$(( $i + 1 ))

			test $i -gt 9 && return
		fi
	done
}


load_config()
{
	local file="$2"

	if [ -f "$file" ]
	then
		LOG "Reading boot item [$1] from file $file"

		eval $( /sbin/multiboot_read_item FN=$1 $file )
	fi
}


store_config()
{
	local file="$2"

	LOG "Storing boot configuration into file $file"

cat > $file << EOM
ITEM_ID="$( array ID $1 )"
ITEM_NAME="$( array NAME $1 )"
ITEM_KERNEL="$( array KERNEL $1 )"
ITEM_MODULES="$( array MODULES $1 )"
ITEM_PARAMS="$( array PARAMS $1 )"
ITEM_DEVICE="$( array FS_ROOT $1 )"
ITEM_FSTYPE="$( array FS_TYPE $1 )"
ITEM_FSOPTIONS="$( array FS_OPTS $1 )"
ITEM_LINUXRC="$( array INITRC $1 )"
ITEM_INITFS="$( array INITFS $1 )"
EOM
}


flash_kernel()
{
	LOG "Flashing kernel file $1"

	ifconfig lo 127.0.0.1 netmask 255.0.0.0 up

	softupd --local --verbose --stdout --standalone &
	flasher --local --flash --kernel $1

	ifconfig lo down
}


swap_kernel()
{
	local KERNEL=$( array KERNEL $1 )
	local VMLINUZ='none'

	for prefix in ${VMLINUZ_SEARCH}
	do
		if [ -f ${prefix}${KERNEL} -a -d /lib/modules/${KERNEL} ]
		then
			VMLINUZ=${prefix}${KERNEL}
			break
		fi
	done

	if [ -f ${VMLINUZ} ]
	then
		run store_config $1 ${BOOT_ITEM}
		run touch ${BOOT_FAST}

		run flash_kernel ${VMLINUZ}

		safe_reboot
	else
		ERROR "Can't flash kernel, required files not found"
	fi
}



################################################################################################
#
# SCREEN FUNCTIONS
#
################################################################################################

wait_keypress()
{
	local t

	t=$MAIN_TIMEOUT

	while [ $t -gt 0 ]
	do
		text2screen -t "[$t] " -s 2 -x 700 -y 108 -B ${BLACK} -T ${WHITE}

		if get_key 1000
		then
			return 0
		fi

		t=$(( $t - 1 ))
	done

	echo "D"

	return 1
}


init_screen()
{
	SAY '\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n'
	SAY '\r---------------------------------------------------------------------------------------------------\r'
}


clear_screen()
{
	text2screen -c -x 0 -y 0 -w 800 -h 480 -B ${BLACK}
}


wait_screen()
{
        text2screen -c -x 0 -y 0   -w 790 -h 464 -B ${WHITE}
	text2screen -c -x 0 -y 100 -w 790 -h 30  -B ${BLACK}
	text2screen -c -x 0 -y 464 -w 800 -h 16  -B ${BLACK}
	text2screen -c -x 790 -y 0 -w 10 -h 480  -B ${BLACK}

	text2screen -t "$(array NAME $1)" -s 3 -x 40 -y 40 -T ${BLUE} -B ${WHITE}
	text2screen -t "BOOTING - PLEASE WAIT" -s 2 -x 40 -y 108 -T ${WHITE} -B ${BLACK}

	text2screen -t "Kernel  : $(array KERNEL $1)"  -s 2 -x 20 -y 160 -T ${BLACK} -B ${WHITE}
	text2screen -t "Params  : $(array PARAMS $1)"  -s 2 -x 20 -y 180 -T ${BLACK} -B ${WHITE}
	text2screen -t "Modules : $(array MODULES $1)" -s 2 -x 20 -y 200 -T ${BLACK} -B ${WHITE}
	text2screen -t "Device  : $(array FS_ROOT $1)" -s 2 -x 20 -y 220 -T ${BLACK} -B ${WHITE}
	text2screen -t "FS type : $(array FS_TYPE $1)" -s 2 -x 20 -y 240 -T ${BLACK} -B ${WHITE}
	text2screen -t "FS opts : $(array FS_OPTS $1)" -s 2 -x 20 -y 260 -T ${BLACK} -B ${WHITE}
	text2screen -t "linuxrc : $(array INITRC $1)" -s 2 -x 20 -y 280 -T ${BLACK} -B ${WHITE}
	text2screen -t "initfs  : $(array INITFS $1)" -s 2 -x 20 -y 300 -T ${BLACK} -B ${WHITE}
}


error_screen()
{
	text2screen -c -x 0 -y   0 -w 790 -h 100 -B ${RED}
	text2screen -c -x 0 -y 100 -w 790 -h 364 -B ${WHITE}
	text2screen -c -x 10 -y 10 -w 770 -h  80 -B ${BLACK}

	text2screen -t "$1" -s 2 -x 40 -y 30 -T ${RED} -B ${BLACK}
	text2screen -t "Guru Meditation #00000025.62017712" -s 2 -x 120 -y 60 -T ${RED} -B ${BLACK}

	text2screen -t "Hit any key to panic" -s 1 -x 320 -y 260 -T ${BLACK} -B ${WHITE}
}


print_menu()
{
	local x y i

        text2screen -c -x 0 -y 0   -w 790 -h 464 -B ${WHITE}
	text2screen -c -x 0 -y 100 -w 790 -h 30  -B ${BLACK}
	text2screen -c -x 0 -y 464 -w 800 -h 16  -B ${BLACK}
	text2screen -c -x 790 -y 0 -w 10  -h 480 -B ${BLACK}

	text2screen -t "NOKIA N900 - MULTIBOOT" -s 3 -x 40 -y 40 -T ${BLUE} -B ${WHITE}
	text2screen -t "Press a key to select" -s 2 -x 40 -y 108 -T ${WHITE} -B ${BLACK}

	text2screen -t "Press B to boot Maemo with the running kernel - Press X for poweroff - Press ENTER for default" -s 1 -x 10 -y 454 -T ${GREY} -B ${WHITE}

	x=60
	y=160

	for i in ${ITEM_LIST}
	do
		text2screen -t "$i - $(array NAME $i)" -x $x -y $y -T ${BLACK} -B ${WHITE} -s 2
		y=$(( $y + 22 ))
	done
}



################################################################################################
#
# ENVIRONMENT FUNCTIONS
#
################################################################################################

init_log()
{
	test -f ${BOOT_LOGF}.5  &&  mv -f ${BOOT_LOGF}.5 ${BOOT_LOGF}.6
	test -f ${BOOT_LOGF}.4  &&  mv -f ${BOOT_LOGF}.4 ${BOOT_LOGF}.5
	test -f ${BOOT_LOGF}.3  &&  mv -f ${BOOT_LOGF}.3 ${BOOT_LOGF}.4
	test -f ${BOOT_LOGF}.2  &&  mv -f ${BOOT_LOGF}.2 ${BOOT_LOGF}.3
	test -f ${BOOT_LOGF}.1  &&  mv -f ${BOOT_LOGF}.1 ${BOOT_LOGF}.2
	test -f ${BOOT_LOGF}    &&  mv -f ${BOOT_LOGF}   ${BOOT_LOGF}.1

	exec 5> ${BOOT_LOGF}

	LOG "MULTIBOOT starting up"
}


init_hw()
{
	LOG "Initializing HW"

	## Kernel modules required in bootup

	load_modules omap_wdt twl4030_wdt
	load_modules omap_hsmmc mmc_core mmc_block
	load_modules twl4030-madc
	load_modules led-class leds-lp5523
}


init_backlight()
{
	LOG "Initializing backlights"

	for i in 1 2 3 4 5 6 ; do
		sysset class/leds/lp5523:kb${i}/brightness 208
	done

	sysset class/backlight/acx565akm/brightness 120
}


init_pm()
{
	LOG "Initializing default power configuration"

	## Default values for Maemo

	sysset power/enable_off_mode         1
	sysset power/sleep_while_idle        1
	sysset power/clocks_off_while_idle   1
	sysset power/voltage_off_while_idle  1
	sysset power/sr_vdd1_autocomp        0
	sysset power/sr_vdd2_autocomp        0

	sysset devices/system/cpu/cpu0/cpufreq/scaling_governor  ondemand
	sysset devices/system/cpu/cpu0/cpufreq/scaling_max_freq  600000
	sysset devices/system/cpu/cpu0/cpufreq/scaling_min_freq  250000

	sysset devices/system/cpu/cpu0/cpufreq/scaling_setspeed  600000
}


init_fs()
{
	LOG "Mounting filesystems: proc sys tmp dev"

	# Mount point for new root
	test -d /mnt || run mkdir -m 0700 /mnt

	# Mount pseudo filesystems
	is_proc_mounted || run mount -t proc  none /proc
	is_sys_mounted  || run mount -t sysfs none /sys
        is_dev_mounted  || run mount -t tmpfs none -o size=128K /dev
        is_tmp_mounted  || run mount -t tmpfs none -o size=512K /tmp

	# Mount for pts
	if ! is_pts_mounted
	then
		run mkdir /dev/pts
		run mount -t devpts devpts /dev/pts -o gid=5,mode=0620
	fi

	# Dev nodes
	LOG "Creating device nodes in /dev"

        run mknod /dev/mem  c 1 1
        run mknod /dev/null c 1 3
        run mknod /dev/zero c 1 5
        run mknod /dev/kmem c 1 2
        run mknod /dev/kmsg c 1 11

        run mknod /dev/mtd0 c 90 0
        run mknod /dev/mtd1 c 90 2
        run mknod /dev/mtd2 c 90 4
        run mknod /dev/mtd3 c 90 6
        run mknod /dev/mtd4 c 90 8
        run mknod /dev/mtd5 c 90 10

	run mknod /dev/mmcblk0   b 179 0
	run mknod /dev/mmcblk0p1 b 179 1
	run mknod /dev/mmcblk0p2 b 179 2
	run mknod /dev/mmcblk0p3 b 179 3
	run mknod /dev/mmcblk0p4 b 179 4
	run mknod /dev/mmcblk0p5 b 179 5
	run mknod /dev/mmcblk0p6 b 179 6
	run mknod /dev/mmcblk0p7 b 179 7

	run mknod /dev/mmcblk1   b 179 8
	run mknod /dev/mmcblk1p1 b 179 9
	run mknod /dev/mmcblk1p2 b 179 10
	run mknod /dev/mmcblk1p3 b 179 11
	run mknod /dev/mmcblk1p4 b 179 12
	run mknod /dev/mmcblk1p5 b 179 13
	run mknod /dev/mmcblk1p6 b 179 14
	run mknod /dev/mmcblk1p7 b 179 15

        run mknod /dev/i2c-1 c 89 1
        run mknod /dev/i2c-2 c 89 2
        run mknod /dev/i2c-3 c 89 3

	run mknod /dev/event0 c 13 64
	run mknod /dev/event1 c 13 65
	run mknod /dev/event2 c 13 66
	run mknod /dev/event3 c 13 67

        run mknod /dev/console c 5 1

	run mknod /dev/fb0 c 29 0
	run mknod /dev/fb1 c 29 1
	run mknod /dev/fb2 c 29 2

	run mknod_misc /dev/watchdog      watchdog
	run mknod_misc /dev/twl4030_wdt   twl4030_wdt
	run mknod_misc /dev/twl4030-adc   twl4030-adc
	run mknod_misc /dev/twl4030-madc  twl4030-adc

	run mkdir -m 0755 /dev/shm

	run ln -s /proc/self/fd   /dev/fd
	run ln -s /proc/self/fd/0 /dev/stdin
	run ln -s /proc/self/fd/1 /dev/stdout
	run ln -s /proc/self/fd/2 /dev/stderr

	## Modules
	LOG "Configuring modules for $(uname -r)"

	# Current link
	run rm -f /lib/modules/current
	run ln -s $(uname -r) /lib/modules/current

	# Depmod
	run depmod -A $(uname -r)

	# Boot reason
	run get_boot_state
}


done_fs()
{
	LOG "Unmounting filesystems: pts dev tmp sys proc"

	# Unmount filesystems
	is_mod_mounted     && run umount /lib/modules/$(uname -r)
	is_pts_mounted     && run umount /dev/pts
	is_dev_mounted     && run umount /dev
	is_tmp_mounted     && run umount /tmp
	is_sys_mounted     && run umount /sys
	is_proc_mounted    && run umount /proc

	# All written to disks
	run sync
}


init_state()
{
	if [  X${BOOT_STATE} = XACT_DEAD ]
	then
		LOG "Booting Maemo in ACT_DEAD"
		boot_maemo
	fi

	if [ -f ${BOOT_FAST} ]
	then
		LOG "Setting FAST_BOOT=YES"
		FAST_BOOT=YES
		rm -f ${BOOT_FAST}
	fi

	if [ -f ${BOOT_ITEM} ]
	then
		run load_config 99 ${BOOT_ITEM}
	fi

	if is_fast_boot || ! is_slide_open
	then
		LOG "Fast-booting the default"
		run boot_item 99
	fi
}


mount_root()
{
	local FS_ROOT=$(array FS_ROOT $1)
	local FS_TYPE=$(array FS_TYPE $1)
	local FS_OPTS=$(array FS_OPTS $1)
	local MODULES=$(array MODULES $1)

	local OPTS=""

	if [ -n "$FS_TYPE" ]
	then
		LOG "Root fs type: ${FS_TYPE}"
		OPTS="${OPTS} -t ${FS_TYPE}"
	fi

	if [ -n "$FS_OPTS" ]
	then
		LOG "Root fs options: ${FS_OPTS}"
		OPTS="${OPTS} -o ${FS_OPTS}"
	fi

	if [ -n "$MODULES" ]
	then
		run load_modules $MODULES
	fi

	if run wait_root_device "${FS_ROOT}" 10
	then
		if run mount $OPTS /dev/${FS_ROOT} /mnt
		then
			LOG "Mounted root device ${FS_ROOT} on /mnt"
		else
			ERROR "Mounting root device ${FS_ROOT} FAILED"
			return 1
		fi
	else
		ERROR "Root device ${FS_ROOT} not accessible"
		return 1
	fi

	return 0
}


prepare_root()
{
	local ROOT="$1"
	local INITFS="$2"
	local MPATH="/lib/modules/$(uname -r)"

	LOG "Preparing root filesystem"

	# Must have initfs mount point
	if [ ! -d ${ROOT}/${INITFS} ]
	then
		run rm -f ${ROOT}/${INITFS}
		run mkdir -m 0755 ${ROOT}/${INITFS}
	fi

	# Current link in modules
	run rm -f ${ROOT}/lib/modules/current
	run ln -s $(uname -r) ${ROOT}/lib/modules/current

	# Modules overlay
	run mount -o bind ${ROOT}/${MPATH} ${MPATH}

	# Depencies - now using the overlay
	run depmod -A $(uname -r)
}


################################################################################################
#
# BOOTING FUNCTIONS
#
################################################################################################

boot_maemo()
{
	LOG "Booting Maemo from MTD"

	# Booting ok - save as default
	case ${BOOT_STATE} in
		BOOT|USER|FLASH|SHUTDOWN)
			run store_config $1 ${BOOT_ITEM}
			;;
	esac

	# Load all kernel modules
	run load_kernel_modules

	# Limits
	ulimit -c unlimited
	ulimit -l unlimited

	# HW Settings
	sysset devices/platform/gpio-switch/cmt_bsi/state active
	sysset devices/platform/serial8250.0/sleep_timeout 10

	# init RUNLEVEL
	case ${BOOT_STATE} in
		BOOT)		INITLEVEL=6  ;;
		USER|FLASH)	INITLEVEL=2  ;;
		ACT_DEAD)	INITLEVEL=5  ;;
		LOCAL|TEST)	INITLEVEL=3  ;;
		SHUTDOWN)	INITLEVEL=0  ;;
	        *) 		INITLEVEL=2  ;;
	esac

	# let me see then, what thereat is and this mistery explore
##	fiasco-do-update

	# Done with filesystems
	run done_fs

	# Start init
	LOG "Starting /sbin/init ${INITLEVEL}"

	# Switch over
	run exec /sbin/init ${INITLEVEL}

	# Fatal error
	ERROR "Excuting Maemo /sbin/init FAILED"

	# Fallback
	safe_reboot
}


boot_chroot()
{
	local INITRC=$(array INITRC $1)
	local INITFS=$(array INITFS $1)

	# No initfs defined
	if [ -z "${INITFS}" ]
	then
		INITFS="mnt/initfs"
	else
		INITFS=${INITFS##/}
	fi

	LOG "initfs in ${INITFS}"

	# Mount new root filesystem
	if mount_root $1
	then
		# Booting ok - save as default
		run store_config $1 ${BOOT_ITEM}

		# Prepare root filesystem
		run prepare_root /mnt ${INITFS}

		# Load all kernel modules
		run load_kernel_modules

		# PM configuration
		run load_pmconfig /mnt

		# Done with extra filesystems
		run done_fs

		# New root location
		cd /mnt || return 1

		# Pivot root into initfs
		run pivot_root . ${INITFS}

		# Switch over
		for file in ${INITRC} ${INIT_SEARCH}
		do
			if [ -x ${file} ]
			then
				LOG "Switching over to ${file}"
				exec chroot . ${file}
				ERROR "Excuting ${file} FAILED"
			fi
		done

		# Fatal error
		ERROR "Can't find init binary in target OS"
	fi

	# Fallback
	safe_reboot
}


boot_kexec()
{
	local KERNEL=$(array KERNEL $1)
	local PARAMS=$(array PARAMS $1)
	local ROOT=$(array FS_ROOT $1)
	local CMDLINE
	local PREFIX="/"

	# New root FS needed
	if [ -n "$ROOT" ]
	then
		if mount_root $1
		then
			PREFIX="/mnt"
		else
			return 1
		fi
	fi

	# Command line
	if [ -n "${PARAMS}" ]
	then
		CMDLINE="${PARAMS}"
	else
		CMDLINE="$(cat /proc/cmdline)"
	fi

	LOG "Booting [${PREFIX}]${KERNEL} ${CMDLINE}"

	if [ -e "${PREFIX}${KERNEL}" ]
	then
		# Load new kernel
		run kexec -l "${PREFIX}${KERNEL}" --command-line="${CMDLINE}"

		# Done with FS access
		run done_fs

		# Start the kernel
		run exec kexec -f -e
	else
		ERROR "kernel version ${KERNEL} not found."
	fi

	# Fallback
	safe_reboot
}


boot_script()
{
	if [ -x $1 ]
	then
		LOG "Running script $@"

		# Clear screen
		clear_screen

		# Start the script
		eval "$@"

		# Fallback
		safe_reboot
	else
		LOG "Script $1 does not exist."
	fi
}


boot_default()
{
	wait_screen 0

	LOG "Booting default"

	case $(uname -r) in
		2.6.28-omap1) 			boot_maemo ;;
		2.6.28.10power[0-9][0-9])	boot_maemo ;;
	esac

	if [ X${FAST_BOOT} != XYES ]
	then
		run swap_kernel 0
	fi

	ERROR "Maemo kernel not available!"
}


boot_item()
{
	local NAME=$(array NAME $1)
	local ROOT=$(array FS_ROOT $1)
	local KERNEL=$(array KERNEL $1)

	if [ -n "$NAME" ]
	then
		wait_screen $1

		LOG "Booting item #$1"

		if [ -z "$KERNEL" -o "$KERNEL" == "$(uname -r)" ]
		then
			if [ -z "$ROOT" ]
			then
				run boot_maemo $1
			else
				run boot_chroot $1
			fi

			safe_reboot
		else
			if [ X${FAST_BOOT} != XYES ]
			then
				run swap_kernel $1
			fi
		fi
	fi
}


################################################################################################
#
# MAIN FUNCTION
#
################################################################################################

main()
{
	local key

	init_log
	init_hw
	init_fs
	init_pm
	init_state
	init_screen
	init_backlight

	run read_config

	while :
	do
		print_menu

		key=$(wait_keypress)

		SAY -n '\r'

		case $key in

			# Timeout
			D)   key=99 ;;

			# Enter
		        28)  key=99 ;;

			# 1-9
			16)  key=1 ;;
			17)  key=2 ;;
			18)  key=3 ;;
			19)  key=4 ;;
			20)  key=5 ;;
			21)  key=6 ;;
			22)  key=7 ;;
			23)  key=8 ;;
			24)  key=9 ;;

			# 0/B - Boot default
			25|48)  run boot_default ;;

			# Backscape - reboot
			14)  run safe_reboot ;;

			# X - poweroff
			45)  run safe_poweroff ;;

			# ASDFGHJKL - Multiboot plugins
			30)  boot_script /sbin/multiboot_plugin_a ;;
			31)  boot_script /sbin/multiboot_plugin_s ;;
			32)  boot_script /sbin/multiboot_plugin_d ;;
			33)  boot_script /sbin/multiboot_plugin_f ;;
			34)  boot_script /sbin/multiboot_plugin_g ;;
			35)  boot_script /sbin/multiboot_plugin_h ;;
			36)  boot_script /sbin/multiboot_plugin_j ;;
			37)  boot_script /sbin/multiboot_plugin_k ;;
			38)  boot_script /sbin/multiboot_plugin_l ;;

		esac

		run boot_item $key

		LOG "Booting item #${key} failed. Trying again."
	done
}


main

# End
